---
title: "Write unit tests"
weight: 450
---

You've written code to implement the business logic of your hook. As part of software development best practices, you'll now write unit tests to verify that key pieces of your hook work as you expect, thus increasing your level of confidence on your code's functional aspects.

In addition to writing unit tests, you'll also write and run contract tests in this lab, and you'll also run end-to-end tests as well. Let's start with unit tests first.

When you write unit tests, it is important to have a reasonable amount of key code being tested. For that, you use a software metric as an indicator, called [code coverage](https://en.wikipedia.org/wiki/Code_coverage), that expresses the percentage of code you're covering with your unit tests. While a 100% code coverage would be -ideally- desirable, it is not very easy or very practical to achieve -or even needed- in some cases.  Most of the time, it makes sense to agree on a reasonable amount code coverage: for example, 80%. What really matters is which code you're covering with unit tests; think of what the important pieces of your code you want to cover are.

To get started, you'll use [pytest](https://pytest.org/) with the [pytest-cov](https://pytest-cov.readthedocs.io/en/latest/index.html) plugin to run unit tests and to measure code coverage for your hook's code. You should already have installed `pytest-cov` as part of the prerequisites for this lab. Make sure you are in the `example-hook/` directory, and then create an empty code coverage configuration file, called `.coveragerc`:

:::code{language=shell showLineNumbers=false showCopyAction=true}
touch .coveragerc
:::

Next, add this content to the `.coveragerc` file you just created:

:::code{language=text showLineNumbers=false showCopyAction=true}
[report]
fail_under = 80

show_missing = True


[run]
branch = True

include =
    src/*/*

omit =
    */__init__.py
    src/*/models.py
    src/*/target_models/*
    src/*/tests/*
:::

Save the file. When you look at the file above, you note that you're telling `coverage.py` to:

- fail unit tests under 80% of code coverage;
- show which code lines are not covered by your unit tests;
- enable coverage for branches you have in your code (for example, `if` and `else` blocks);
- include the `src/` code path, while excluding files generated by the CloudFormation CLI, and test files in the `tests/` directory.

Next, make sure you're in the `example-hook/` directory; use the following commands to create the `tests` directory inside the `src/examplecompany_s3_versioningenabled/` path, and two empty files (you'll use one of them, `test_handlers.py`, later on to implement your tests):

:::code{language=shell showLineNumbers=false showCopyAction=true}
mkdir src/examplecompany_s3_versioningenabled/tests
touch src/examplecompany_s3_versioningenabled/tests/__init__.py
touch src/examplecompany_s3_versioningenabled/tests/test_handlers.py
:::

Next, add the following content to the `src/examplecompany_s3_versioningenabled/tests/test_handlers.py` empty file you just created:

:::code{language=python showLineNumbers=false showCopyAction=true}
"""Tests: example hook to validate versioning is enabled for an S3 bucket."""

import re
import uuid
from typing import (
    Any,
    MutableMapping,
)

from unittest.mock import (
    patch,
)

from cloudformation_cli_python_lib import (  # type: ignore
    HandlerErrorCode,
    HookContext,
    HookInvocationPoint,
    OperationStatus,
)

from .. import handlers
from ..models import (
    HookHandlerRequest,
    TypeConfigurationModel,
)


# Derive the src sub-directory folder name from the type config
# (example output for this hook: examplecompany_s3_versioningenabled)
HOOK_CODE_SRC_SUBDIR_NAME = re.sub("::", "_", handlers.TYPE_NAME.lower())

MOCK_ACCOUNT_ID = "111122223333"
MOCK_ARN_SUFFIX = "00000000-0000-0000-0000-000000000000"
MOCK_CALLBACK_CONTEXT: MutableMapping[str, Any] = {}
MOCK_HOOK_TYPE_VERSION = "00000001"
MOCK_REGION = "us-east-1"
MOCK_STACK_NAME = "example"
MOCK_TARGET = "AWS::S3::Bucket"
MOCK_TARGET_LOGICAL_ID = "ExampleBucket"

MOCK_STACK_ID = f"arn:aws:cloudformation:{MOCK_REGION}::stack/{MOCK_STACK_NAME}/{MOCK_ARN_SUFFIX}"  # noqa: E501

MOCK_BASE_HOOK_HANDLER_REQUEST = HookHandlerRequest(
    clientRequestToken=str(uuid.uuid4()),
    hookContext=HookContext(
        awsAccountId=MOCK_ACCOUNT_ID,
        hookTypeName=handlers.TYPE_NAME,
        hookTypeVersion=MOCK_HOOK_TYPE_VERSION,
        # Using CREATE_PRE_PROVISION as the invocation point also for
        # tests on the update invocation point, since both create and
        # update invocation points share the same handler code.
        invocationPoint=HookInvocationPoint.CREATE_PRE_PROVISION,
        stackId=MOCK_STACK_ID,
        targetLogicalId=MOCK_TARGET_LOGICAL_ID,
        targetModel=None,
        targetName=MOCK_TARGET,
        targetType=MOCK_TARGET,
    ),
)


def test_when_ignore_s3_bucket_names_is_missing_if_compliant_succeed() -> (  # noqa: D103 E501
    None
):
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {
        "resourceProperties": {
            "VersioningConfiguration": {"Status": "Enabled"},
        },
    }

    response = handlers._run_pre_create_pre_update_common_checks(
        session=None,
        request=MOCK_BASE_HOOK_HANDLER_REQUEST,
        callback_context=MOCK_CALLBACK_CONTEXT,
        type_configuration=TypeConfigurationModel(None),
    )

    assert response.message == "Bucket versioning is enabled."
    assert response.status == OperationStatus.SUCCESS
    assert response.errorCode is None
    assert response.callbackContext is None
    assert response.callbackDelaySeconds == 0


def test_when_ignore_s3_bucket_names_is_missing_if_non_compliant_fail() -> (  # noqa: D103 E501
    None
):
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {
        "resourceProperties": {
            "VersioningConfiguration": {"Status": "Suspended"},
        },
    }

    response = handlers._run_pre_create_pre_update_common_checks(
        session=None,
        request=MOCK_BASE_HOOK_HANDLER_REQUEST,
        callback_context=MOCK_CALLBACK_CONTEXT,
        type_configuration=TypeConfigurationModel(None),
    )

    assert response.message == "Bucket versioning is not enabled."
    assert response.status == OperationStatus.FAILED
    assert response.errorCode == HandlerErrorCode.NonCompliant
    assert response.callbackContext is None
    assert response.callbackDelaySeconds == 0


def test_when_s3_bucket_versioning_status_is_enabled_then_succeed() -> (  # noqa: D103 E501
    None
):
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {
        "resourceProperties": {
            "VersioningConfiguration": {"Status": "Enabled"},
        },
    }

    response = handlers._run_pre_create_pre_update_common_checks(
        session=None,
        request=MOCK_BASE_HOOK_HANDLER_REQUEST,
        callback_context=MOCK_CALLBACK_CONTEXT,
        type_configuration=TypeConfigurationModel(
            IgnoreS3BucketNames="",
        ),
    )

    assert response.message == "Bucket versioning is enabled."
    assert response.status == OperationStatus.SUCCESS
    assert response.errorCode is None
    assert response.callbackContext is None
    assert response.callbackDelaySeconds == 0


def test_when_s3_bucket_versioning_status_is_not_enabled_then_fail() -> (  # noqa: D103 E501
    None
):
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {
        "resourceProperties": {
            "VersioningConfiguration": {"Status": "Suspended"},
        },
    }

    response = handlers._run_pre_create_pre_update_common_checks(
        session=None,
        request=MOCK_BASE_HOOK_HANDLER_REQUEST,
        callback_context=MOCK_CALLBACK_CONTEXT,
        type_configuration=TypeConfigurationModel(
            IgnoreS3BucketNames="",
        ),
    )

    assert response.message == "Bucket versioning is not enabled."
    assert response.status == OperationStatus.FAILED
    assert response.errorCode == HandlerErrorCode.NonCompliant
    assert response.callbackContext is None
    assert response.callbackDelaySeconds == 0


def test_when_s3_bucket_properties_are_missing_then_fail() -> (  # noqa: D103
    None
):
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {}

    response = handlers._run_pre_create_pre_update_common_checks(
        session=None,
        request=MOCK_BASE_HOOK_HANDLER_REQUEST,
        callback_context=MOCK_CALLBACK_CONTEXT,
        type_configuration=TypeConfigurationModel(
            IgnoreS3BucketNames="",
        ),
    )

    assert response.message == "The S3 bucket has no properties set."
    assert response.status == OperationStatus.FAILED
    assert response.errorCode == HandlerErrorCode.NonCompliant
    assert response.callbackContext is None
    assert response.callbackDelaySeconds == 0


def test_when_s3_bucket_versioning_property_is_missing_then_fail() -> (  # noqa: D103 E501
    None
):
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {
        "resourceProperties": {
            "VersioningConfiguration": None,
        },
    }

    response = handlers._run_pre_create_pre_update_common_checks(
        session=None,
        request=MOCK_BASE_HOOK_HANDLER_REQUEST,
        callback_context=MOCK_CALLBACK_CONTEXT,
        type_configuration=TypeConfigurationModel(
            IgnoreS3BucketNames="",
        ),
    )

    assert (
        response.message
        == "The VersioningConfiguration property value is missing."
    )
    assert response.status == OperationStatus.FAILED
    assert response.errorCode == HandlerErrorCode.NonCompliant
    assert response.callbackContext is None
    assert response.callbackDelaySeconds == 0


def test_when_exception_is_thrown_then_fail() -> None:  # noqa: D103
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {}

    with patch(
        f"{HOOK_CODE_SRC_SUBDIR_NAME}.handlers._get_target_model",
        side_effect=ValueError("Example error."),
    ):
        response = handlers._run_pre_create_pre_update_common_checks(
            session=None,
            request=MOCK_BASE_HOOK_HANDLER_REQUEST,
            callback_context=MOCK_CALLBACK_CONTEXT,
            type_configuration=TypeConfigurationModel(
                IgnoreS3BucketNames="",
            ),
        )

        assert response.message == "Example error."
        assert response.status == OperationStatus.FAILED
        assert response.errorCode == HandlerErrorCode.InternalFailure
        assert response.callbackContext is None
        assert response.callbackDelaySeconds == 0


def test_when_s3_bucket_name_is_not_ignored_then_if_non_compliant_fail() -> (  # noqa: D103 E501
    None
):
    MOCK_BASE_HOOK_HANDLER_REQUEST.hookContext.targetModel = {
        "resourceProperties": {
            "BucketName": "my-non-ignored-bucket",
            "VersioningConfiguration": {"Status": "Suspended"},
        },
    }

    response = handlers._run_pre_create_pre_update_common_checks(
        session=None,
        request=MOCK_BASE_HOOK_HANDLER_REQUEST,
        callback_context=MOCK_CALLBACK_CONTEXT,
        type_configuration=TypeConfigurationModel(
            IgnoreS3BucketNames="my-ignored-bucket,my-other-ignored-bucket",
        ),
    )

    assert response.message == "Bucket versioning is not enabled."
    assert response.status == OperationStatus.FAILED
    assert response.errorCode == HandlerErrorCode.NonCompliant
    assert response.callbackContext is None
    assert response.callbackDelaySeconds == 0
:::

Save the file. Look at the example unit test code you just added: can you recognize which parts of the code are covered? As you can see, in this file you first set some variables on top of the code, and you reference these variables in `MOCK_BASE_HOOK_HANDLER_REQUEST` that you reuse across unit test methods. In each method, you create a mock of the target model, and run the handler code to assert either success or failure scenarios.

Next, type the following command from the `example-hook/` directory to run unit tests:

:::code{language=shell showLineNumbers=false showCopyAction=true}
pytest --cov
:::

Congratulations! Your code coverage is slightly above 80%. There are some other lines of code that you could cover, but let's move on for now.

Next, run `mypy` against your `test_handlers.py` file (make sure you are in the `example-hook/` directory):

:::code{language=shell showLineNumbers=false showCopyAction=true}
mypy src/examplecompany_s3_versioningenabled/tests/test_handlers.py
:::

You should see an output indicating no errors. Next, run `flake8` against the same file:

:::code{language=shell showLineNumbers=false showCopyAction=true}
flake8 \
    --docstring-convention pep257 \
    --ignore=W503,W504 \
    --max-complexity=10 \
    --max-line-length=79 \
    src/examplecompany_s3_versioningenabled/tests/test_handlers.py
:::

You should see no output messages, indicating no errors have occurred.

Choose **Next** to continue!
